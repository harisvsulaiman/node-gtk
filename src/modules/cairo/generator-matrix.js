/*
 * generate-matrix.js
 */

const fs = require('fs')
const path = require('path')
const util = require('util')
const removeTrailingSpaces = require('remove-trailing-spaces')
const unindent = require('./unindent.js')

const {
  ENUM_TYPE,
  WRAP_TYPE,
  logFn,
  getSource,
  getInArgumentSource,
  getOutArgumentDeclaration,
  getFunctionCall,
  getFunctionArgument,
  getReturn,
  getAttachMethods,
  parseFile,
  getInArguments,
  getOutArguments,
  getTypeName,
  getJSName,
} = require('./generator.js')


util.inspect.defaultOptions = { depth: 6 }

generateCairoMatrix()

function generateCairoMatrix() {
  const result = parseFile(path.join(__dirname, 'cairo-matrix.nid'))
  const declarations = result.declarations

  console.log(declarations)

  const constructor = declarations.find(d => d.function && d.function.attributes.constructor).function
  const functions =
    declarations
      .filter(d => d.function && !d.function.attributes.constructor)
      .map(d => {
        const fn = d.function
        fn.source = generateClassMethodSource(fn, { name: 'Matrix' })
        return fn
      })

  const header = generateHeader({ name: 'Matrix', constructor, functions })
  const source = generateSource({ name: 'Matrix', constructor, functions })

  fs.writeFileSync(path.join(__dirname, 'cairo-matrix.h'),  header)
  fs.writeFileSync(path.join(__dirname, 'cairo-matrix.cc'), source)
}

// Helpers

function generateHeader(options) {
  const classDeclaration = generateClassDeclaration(options)

  return removeTrailingSpaces(unindent(`

    /* autogenerated by ${path.basename(__filename)} */

    #pragma once

    #include <nan.h>
    #include <node.h>
    #include <girepository.h>
    #include <glib.h>
    #include <cairo.h>

    namespace GNodeJS {

    namespace Cairo {

    ${classDeclaration}

    }; // Cairo

    }; // GNodeJS

  `))
}

function generateSource(options) {

  const classVariables   = generateClassVariables(options)
  const templateMethods  = generateTemplateMethods(options)
  const initializeMethod = generateInitializeMethod(options)
  const newMethod        = generateNewMethod(options)
  const methods          = options.functions.map(fn => fn.source).join('\n')

  return removeTrailingSpaces(unindent(`

    /* autogenerated by ${path.basename(__filename)} */

    #include "../../debug.h"
    #include "../../gi.h"
    #include "../../util.h"
    #include "cairo-matrix.h"
    #include "cairo-rectangle.h"
    #include "cairo-rectangle-int.h"

    using namespace v8;


    namespace GNodeJS {

    namespace Cairo {


    ${classVariables}


    /*
     * Initialize matrix.
     */

    Matrix::Matrix(cairo_matrix_t* data) : ObjectWrap() {
      _data = data;
    }

    /*
     * Destroy matrix..
     */

    Matrix::~Matrix() {
      if (_data != NULL) {
        delete _data;
      }
    }


    /*
     * Template methods
     */

    ${templateMethods}


    /*
     * Initialize method
     */

    ${initializeMethod}


    /*
     * Instance constructors
     */

    ${newMethod}


    /*
     * Methods
     */

    ${methods}



    }; // Cairo

    }; // GNodeJS


  `))
}

function generateClassDeclaration(options) {

  return `
    class ${options.name}: public Nan::ObjectWrap {
      public:
        static Nan::Persistent<v8::FunctionTemplate> constructorTemplate;
        static Nan::Persistent<v8::Function>         constructor;
        static void Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target);
        static void SetupTemplate();
        static Local<v8::FunctionTemplate> GetTemplate();
        static Local<v8::Function> GetConstructor();

        static NAN_METHOD(New);

        ${options.functions.map(fn => `static NAN_METHOD(${getFunctionJSName(fn)});`).join('\n        ')}

        ${options.name}(cairo_matrix_t* data);
        ~${options.name}();

        cairo_matrix_t* _data;
    }
  `
}

function generateClassVariables(options) {
  return `
    Nan::Persistent<FunctionTemplate> ${options.name}::constructorTemplate;
    Nan::Persistent<Function>         ${options.name}::constructor;
  `
}

function generateTemplateMethods(options) {

  const staticMethods = options.functions.filter(fn => fn.attributes.static)
  const methods = options.functions.filter(fn => fn.attributes.static !== true)

  return `
    Local<FunctionTemplate> ${options.name}::GetTemplate() {
      if (constructorTemplate.IsEmpty())
        ${options.name}::SetupTemplate();
      return Nan::New<FunctionTemplate> (constructorTemplate);
    }

    Local<Function> ${options.name}::GetConstructor() {
      if (constructor.IsEmpty())
        ${options.name}::SetupTemplate();
      return Nan::New<Function> (constructor);
    }

    void ${options.name}::SetupTemplate() {

      // Constructor
      auto tpl = Nan::New<FunctionTemplate>(${options.name}::New);
      tpl->InstanceTemplate()->SetInternalFieldCount(1);
      tpl->SetClassName(Nan::New("Cairo${options.name}").ToLocalChecked());

      ${methods.map(fn => `SET_PROTOTYPE_METHOD(tpl, ${getFunctionJSName(fn)});`).join('\n      ')}

      auto ctor = tpl->GetFunction();

      ${staticMethods.map(fn => `SET_METHOD(ctor, ${getFunctionJSName(fn)});`).join('\n      ')}

      constructorTemplate.Reset(tpl);
      constructor.Reset(ctor);
    }
  `
}

function generateInitializeMethod(options) {
  return `
    void ${options.name}::Initialize(Nan::ADDON_REGISTER_FUNCTION_ARGS_TYPE target) {
      Nan::Set (target, Nan::New ("${options.name}").ToLocalChecked(), ${options.name}::GetConstructor());
    }
  `
}

function generateClassMethodSource(fn, options) {
  const selfArgument = fn.attributes.static !== true ? fn.parameters[0] : undefined
  const inArguments  = getInArguments(fn, 'cairo_matrix_t')
  const outArguments = getOutArguments(fn, 'cairo_matrix_t')
  const hasResult = getTypeName(fn.type) !== 'void' || outArguments.length > 0

  return `
    NAN_METHOD(${options.name}::${getFunctionJSName(fn)}) {${selfArgument ? `
        auto self = info.This();
        auto ${selfArgument.name} = Nan::ObjectWrap::Unwrap<${options.name}>(self)->_data;
` : ''}${inArguments.length > 0 ? `
        // in-arguments
        ${inArguments.map(getInArgumentSource).join('\n        ')}
` : ''}${outArguments.length > 0 ? `
        // out-arguments
        ${outArguments.map(getOutArgumentDeclaration).join('\n        ')}
` : ''}
        // function call
        ${getFunctionCall(fn)}
${hasResult ? `
        // return
        ${getReturn(fn, outArguments)}
` : ''}    }
  `
}

function generateNewMethod(options) {
  const constructor = options.constructor
  const parameters = constructor.parameters.slice(1)

  return `

    NAN_METHOD(${options.name}::New) {
      if (!info.IsConstructCall()) {
        return Nan::ThrowTypeError("Class constructors cannot be invoked without 'new'");
      }

      cairo_matrix_t* data = NULL;

      if (info[0]->IsExternal()) {
        data = (cairo_matrix_t*) External::Cast (*info[0])->Value ();
      }
      else if (info.Length() == ${parameters.length}) {
        ${parameters.map(getInArgumentSource).join('\n        ')}

        data = new cairo_matrix_t();
        ${constructor.name} (data, ${parameters.map(p => p.name).join(', ')});
      }
      else {
        return Nan::ThrowError("Cannot instantiate ${options.name}: requires ${constructor.parameters.length} arguments");
      }

      ${options.name}* matrix = new ${options.name}(data);
      matrix->Wrap(info.This());

      info.GetReturnValue().Set(info.This());
    }
  `
}

function getFunctionJSName(fn) {
  return getJSName(fn.name, /cairo_[a-z0-9]+(_matrix)?/)
}
